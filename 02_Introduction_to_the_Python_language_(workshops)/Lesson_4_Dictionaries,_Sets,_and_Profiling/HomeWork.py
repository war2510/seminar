print("\033[H\033[J")  # Очистка консоли

"""
Даны два неупорядоченных набора целых чисел (может быть, с повторениями). Выдать без повторений в порядке возрастания все те числа, которые встречаются в обоих наборах.
"""

var1 = "5 4"  # количество элементов первого и второго множества
var2 = "1 3 5 7 9"  # элементы первого множества через пробел
var3 = "2 3 4 5"  # элементы второго множества через пробел
# На выходе: 3 5

list1 = set(var2.split())
list1.intersection_update(set(var3.split()))
common_elements = sorted(list(list1))

print(*common_elements)

"""
На вход программе подается список arr, где arr[i] (1 ≤ arr[i] ≤ 1000) - урожайность i-го куста черники. Размер списка не превышает 1000 элементов.
Программа должна вывести одно целое число - максимальное количество ягод, которое может собрать собирающий модуль с трех соседних кустов.
"""
arr = [5, 8, 6, 4, 9, 2, 7, 3]
# На выходе: 19


# Проверка на случай, если элементов меньше трех
res = 0 if len(arr) < 3 else sum(arr[:3])

for i in range(len(arr)):
	# Использование модульной арифметики для циклического обращения к элементам
	# sum_current = arr[i] + arr[(i + 1) % len(arr)] + arr[(i + 2) % len(arr)]
	sum_current = arr[i] + arr[i - 1] + arr[i - 2]

	res = max(res, sum_current)


print(res)


"""
Модульная арифметика для индексов — это мощный приём, который позволяет обращаться к элементам списка (или массива) циклически.
Это особенно полезно, когда вам нужно "завернуть" индексы вокруг краёв списка, чтобы они автоматически перешли с конца списка на его начало и наоборот.
Как это работает
Предположим, у вас есть список arr с n элементами и вы хотите получить доступ к элементу следующим за последним (то есть к первому элементу списка) без выхода за границы.
Используя модульную арифметику, вы можете сделать это следующим образом:
index = (текущий_индекс + смещение) % n

Примеры использования
Доступ к следующему элементу: Допустим, у вас есть список из 5 элементов. Чтобы получить доступ к элементу, следующему за последним (то есть вернуться к началу списка),
вы можете использовать (текущий_индекс + 1) % 5. Если текущий_индекс равен 4 (последний элемент), (4 + 1) % 5 даст вам 0, то есть индекс первого элемента.

Доступ к предыдущему элементу: Чтобы получить доступ к элементу, предшествующему первому (то есть перейти к последнему элементу списка),
вы можете использовать (текущий_индекс - 1 + n) % n. Если текущий_индекс равен 0, (0 - 1 + 5) % 5 даст вам 4, то есть индекс последнего элемента в списке из 5 элементов.
"""
